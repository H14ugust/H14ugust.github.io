<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Java线程生命周期 | H14ugust&#39;s Blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url()">
        </div>
    </section>
    <section class='menu'>
        <div>H14ugust&#39;s Blog</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Java线程生命周期</h1>
    </header>

    <section>
      <h1 id="Java线程生命周期"><a href="#Java线程生命周期" class="headerlink" title="Java线程生命周期"></a>Java线程生命周期</h1><h2 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1.线程状态"></a>1.线程状态</h2><p>Java线程在运行的生命周期中，再给定的一个时刻，只能处于其中的一个状态。</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但还没有调用<code>start()</code>方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，Java线程将操作系统中的<strong>就绪和运行</strong>两种状态笼统称为“运行中”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一定特定动作(通知或中断)</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，该状态不同于WATING，它可以在指定的时间自行返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="2-Java线程状态变迁"><a href="#2-Java线程状态变迁" class="headerlink" title="2.Java线程状态变迁"></a>2.Java线程状态变迁</h2><img src="/2019/06/11/Java线程生命周期/1.png" title="Java线程生命周期">
<ul>
<li>阻塞状态是线程在进入<code>synchronized</code>代码块(获取锁)时的状态，但阻塞在<code>J.U.C.Lock</code>接口的线程状态是等待状态，因为<code>J.U.C.Lock</code>对于阻塞的实现均使用了<code>LockSupport</code>类中的相关方法</li>
</ul>
<h2 id="3-等待和阻塞"><a href="#3-等待和阻塞" class="headerlink" title="3.等待和阻塞"></a>3.等待和阻塞</h2><ul>
<li>等待线程(执行了<code>wait()</code>方法)被JVM放入<strong>等待队列</strong></li>
<li>阻塞线程(等待获取对象锁)被JVM放入<strong>同步队列</strong></li>
<li>其它阻塞(<code>sleep()</code>或<code>join()</code>等)</li>
</ul>
<h2 id="4-Wait、Sleep、Yield"><a href="#4-Wait、Sleep、Yield" class="headerlink" title="4.Wait、Sleep、Yield"></a>4.Wait、Sleep、Yield</h2><h3 id="1-wait、sleep和Yield"><a href="#1-wait、sleep和Yield" class="headerlink" title="1.wait、sleep和Yield"></a>1.wait、sleep和Yield</h3><ul>
<li>都能用来暂停线程</li>
<li><code>sleep()</code>和<code>yield()</code>方法是定义在<code>Thread</code>类中，而<code>wait()</code>方法是定义在<code>Object</code>类中的</li>
</ul>
<h3 id="2-wait和sleep的区别"><a href="#2-wait和sleep的区别" class="headerlink" title="2. wait和sleep的区别"></a>2. wait和sleep的区别</h3><ul>
<li><code>wait()</code>是用于线程间通信的，而<code>sleep()</code>是用于短时间暂停当前线程。</li>
<li><strong>当一个线程调用<code>wait()</code>方法的时候，会释放它锁持有的对象的管程和锁，但是调用<code>sleep()</code>方法的时候，不会释放他所持有的管程</strong>。</li>
<li><p><code>wait()</code>方法应在同步代码块中调用，但是<code>sleep()</code>方法不需要</p>
</li>
<li><p><code>Thread.sleep()</code>方法是一个静态方法，作用在当前线程上；但是<code>wait()</code>方法是一个实例方法，并且只能在其他线程调用本实例的notify()方法时被唤醒</p>
</li>
<li>使用<code>sleep()</code>方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用<code>wait()</code>方法的时候，唤醒被暂停的线程会首先竞争锁（译者注：阻塞态），然后再进入就绪态</li>
</ul>
<h3 id="3-yield和sleep的区别"><a href="#3-yield和sleep的区别" class="headerlink" title="3. yield和sleep的区别"></a>3. yield和sleep的区别</h3><ul>
<li>yield和sleep的主要是，yield方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。执行了yield方法的线程什么时候会继续运行由线程调度器来决定，不同的厂商可能有不同的行为。yield方法不保证当前的线程会暂停或者停止，但是可以保证当前线程在调用yield方法时会放弃CPU。</li>
</ul>
<blockquote>
<p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fjavarevisited.blogspot.com%2F2011%2F12%2Fdifference-between-wait-sleep-yield.html" target="_blank" rel="noopener">Difference between Wait and Sleep, Yield in Java</a> </p>
</blockquote>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2019-06-11T08:04:53.000Z" itemprop="datePublished">
              2019-06-11
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2019 - H14ugust </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>